from datetime import datetime
import hashlib
import hmac
from hume.client import AsyncHumeClient
from hume.empathic_voice.types import ReturnChatEvent
import os
from starlette.datastructures import Headers
import time

async def fetch_all_chat_events(chat_id: str) -> list[ReturnChatEvent]:
    """
    Fetches all Chat Events for the given chat ID using the AsyncHumeClient.
    The function returns all events in chronological order.

    :param chat_id: The unique identifier of the chat to fetch events for.
    :return: A list of ReturnChatEvent objects representing all fetched events.
    :raises ValueError: If HUME_API_KEY is not set in environment variables.
    """
    api_key = os.environ.get("HUME_API_KEY")
    if not api_key:
        raise ValueError("HUME_API_KEY is not set in the environment variables.")

    client = AsyncHumeClient(api_key=api_key)

    all_chat_events: list[ReturnChatEvent] = []
    # The response is an iterator over Chat Events
    response = await client.empathic_voice.chats.list_chat_events(id=chat_id, page_number=0, ascending_order=True)
    async for event in response:
        all_chat_events.append(event)
    return all_chat_events

def construct_transcript(chat_events: list[ReturnChatEvent]) -> str:
    """
    Constructs a formatted transcript string from the given chat events.
    Only user and assistant messages are included. Each line includes a timestamp,
    the speaker role, and the message text.

    :param chat_events: A list of chat events to parse.
    :return: A multi-line string representing the transcript.
    """
    # Filter for user and assistant messages
    relevant_events = [e for e in chat_events if e.type in ("USER_MESSAGE", "AGENT_MESSAGE")]

    lines: list[str] = []
    for event in relevant_events:
        role = "User" if event.role == "USER" else "Assistant"
        timestamp = event.timestamp
        dt = datetime.fromtimestamp(timestamp / 1000.0)
        readable_time = dt.strftime("%Y-%m-%d %H:%M:%S")
        lines.append(f"[{readable_time}] {role}: {event.message_text}")

    return "\n".join(lines)

def save_transcript_to_file(transcript: str, chat_id: str) -> None:
    """
    Saves the given transcript to a .txt file with a name based on the chat ID.

    Args:
        transcript (str): The transcript text to save.
        chat_id (str): The chat ID used to name the file.
    """
    transcript_file_name = f"transcript_{chat_id}.txt"
    with open(transcript_file_name, "w", encoding="utf-8") as f:
        f.write(transcript)
    print(f"Transcript saved to {transcript_file_name}")

async def get_chat_transcript(chat_id: str) -> None:
    # Fetch all chat events for the given chat_id
    chat_events = await fetch_all_chat_events(chat_id)

    # Construct a formatted transcript string
    transcript = construct_transcript(chat_events)

    # Save the transcript to a .txt file
    save_transcript_to_file(transcript, chat_id)

def validate_hmac_signature(payload: str, timestamp: str, signature: str) -> None:
    """
    Validates the HMAC signature of an incoming request.

    The signature is generated by concatenating the payload and timestamp, then hashing
    the result using the HMAC-SHA256 algorithm with the API key as the secret.

    Args:
        payload (str): The raw request payload as a string.
        timestamp (str): The timestamp sent in the request headers.
        signature (str): The HMAC signature sent in the request headers.

    Raises:
        ValueError: If the signature is invalid or the API key is missing.
    """
    api_key = os.environ.get("HUME_API_KEY")
    if not api_key:
        print("Error: HUME_API_KEY is not set in environment variables.")
        raise ValueError("Missing API key")

    message = (payload + "." + timestamp).encode("utf-8")
    expected_sig = hmac.new(
        key=api_key.encode("utf-8"),
        msg=message,
        digestmod=hashlib.sha256,
    ).hexdigest()

    print("Debugging HMAC Validation:")
    print("Payload:", payload)
    print("Timestamp:", timestamp)
    print("Generated Signature:", expected_sig)
    print("Received Signature:", signature)

    valid_signature = hmac.compare_digest(signature, expected_sig)
    if not valid_signature:
        print(f"Error: Invalid HMAC signature. Expected: {expected_sig}, Received: {signature}")
        raise ValueError("Invalid HMAC signature")

    print("HMAC validation successful!")

def validate_timestamp(timestamp: str) -> None:
    """
    Validates the timestamp of an incoming request.

    Ensures the timestamp is within an acceptable time window (e.g., 3 minutes)
    to prevent replay attacks.

    Args:
        timestamp (str): The timestamp sent in the request headers.

    Raises:
        ValueError: If the timestamp is older than the allowed time window or improperly formatted.
    """
    try:
        current_time = int(time.time())
        timestamp_int = int(timestamp)
    except ValueError:
        print(f"Error: Invalid timestamp format: {timestamp}")
        raise ValueError("Invalid timestamp format")

    if current_time - timestamp_int > 180:
        print(f"Error: The timestamp on the request is too old. Current time: {current_time}, Timestamp: {timestamp}")
        raise ValueError("The timestamp on the request is too old")

    print("Timestamp validation successful!")

def validate_headers(payload: str, headers: Headers) -> None:
    """
    Validates the headers of an incoming request.

    Ensures that the required headers (`X-Hume-AI-Webhook-Timestamp` and 
    `X-Hume-AI-Webhook-Signature`) are present and valid. Performs HMAC 
    signature validation and timestamp validation.

    Args:
        payload (str): The raw request payload as a string.
        headers (Headers): The headers from the incoming request.

    Raises:
        ValueError: If any validation fails, such as missing headers, invalid
                    signatures, or an outdated timestamp.
    """
    print("Validating headers...")

    timestamp = headers.get("X-Hume-AI-Webhook-Timestamp")
    signature = headers.get("X-Hume-AI-Webhook-Signature")

    if not signature:
        print("Error: Missing HMAC signature.")
        raise ValueError("Missing HMAC signature")

    if not timestamp:
        print("Error: Missing timestamp.")
        raise ValueError("Missing timestamp")

    validate_hmac_signature(payload, timestamp, signature)
    validate_timestamp(timestamp)
