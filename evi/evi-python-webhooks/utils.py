import os
import time
from datetime import datetime
import hashlib
import hmac
import json
import httpx
from starlette.datastructures import Headers
from hume.client import AsyncHumeClient
from hume.empathic_voice.control_plane.client import AsyncControlPlaneClient
from hume.empathic_voice.types import ReturnChatEvent
from hume.empathic_voice import ToolCallMessage, ToolErrorMessage, ToolResponseMessage

async def fetch_all_chat_events(client: AsyncHumeClient, chat_id: str) -> list[ReturnChatEvent]:
    """
    Fetches all Chat Events for the given chat ID using the AsyncHumeClient.
    The function returns all events in chronological order.

    :param chat_id: The unique identifier of the chat to fetch events for.
    :return: A list of ReturnChatEvent objects representing all fetched events.
    :raises ValueError: If HUME_API_KEY is not set in environment variables.
    """
    all_chat_events: list[ReturnChatEvent] = []
    # The response is an iterator over Chat Events
    response = await client.empathic_voice.chats.list_chat_events(id=chat_id, page_number=0, ascending_order=True)
    async for event in response:
        all_chat_events.append(event)
    return all_chat_events

def construct_transcript(chat_events: list[ReturnChatEvent]) -> str:
    """
    Constructs a formatted transcript string from the given chat events.
    Only user and assistant messages are included. Each line includes a timestamp,
    the speaker role, and the message text.

    :param chat_events: A list of chat events to parse.
    :return: A multi-line string representing the transcript.
    """
    # Filter for user and assistant messages
    relevant_events = [e for e in chat_events if e.type in ("USER_MESSAGE", "AGENT_MESSAGE")]

    lines: list[str] = []
    for event in relevant_events:
        role = "User" if event.role == "USER" else "Assistant"
        timestamp = event.timestamp
        dt = datetime.fromtimestamp(timestamp / 1000.0)
        readable_time = dt.strftime("%Y-%m-%d %H:%M:%S")
        lines.append(f"[{readable_time}] {role}: {event.message_text}")

    return "\n".join(lines)

def save_transcript_to_file(transcript: str, chat_id: str) -> None:
    """
    Saves the given transcript to a .txt file with a name based on the chat ID.

    Args:
        transcript (str): The transcript text to save.
        chat_id (str): The chat ID used to name the file.
    """
    transcript_file_name = f"transcript_{chat_id}.txt"
    with open(transcript_file_name, "w", encoding="utf-8") as f:
        f.write(transcript)
    print(f"Transcript saved to {transcript_file_name}")

async def get_chat_transcript(client: AsyncHumeClient, chat_id: str) -> None:
    # Fetch all chat events for the given chat_id
    chat_events = await fetch_all_chat_events(client, chat_id)

    # Construct a formatted transcript string
    transcript = construct_transcript(chat_events)

    # Save the transcript to a .txt file
    save_transcript_to_file(transcript, chat_id)

def validate_hmac_signature(payload: str, timestamp: str, signature: str) -> None:
    """
    Validates the HMAC signature of an incoming request.

    The signature is generated by concatenating the payload and timestamp, then hashing
    the result using the HMAC-SHA256 algorithm with the API key as the secret.

    Args:
        payload (str): The raw request payload as a string.
        timestamp (str): The timestamp sent in the request headers.
        signature (str): The HMAC signature sent in the request headers.

    Raises:
        ValueError: If the signature is invalid or the API key is missing.
    """
    api_key = os.environ.get("HUME_API_KEY")
    if not api_key:
        print("Error: HUME_API_KEY is not set in environment variables.")
        raise ValueError("Missing API key")

    message = (payload + "." + timestamp).encode("utf-8")
    expected_sig = hmac.new(
        key=api_key.encode("utf-8"),
        msg=message,
        digestmod=hashlib.sha256,
    ).hexdigest()

    print("Debugging HMAC Validation:")
    print("Payload:", payload)
    print("Timestamp:", timestamp)
    print("Generated Signature:", expected_sig)
    print("Received Signature:", signature)

    valid_signature = hmac.compare_digest(signature, expected_sig)
    if not valid_signature:
        print(f"Error: Invalid HMAC signature. Expected: {expected_sig}, Received: {signature}")
        raise ValueError("Invalid HMAC signature")

    print("HMAC validation successful!")

def validate_timestamp(timestamp: str) -> None:
    """
    Validates the timestamp of an incoming request.

    Ensures the timestamp is within an acceptable time window (e.g., 3 minutes)
    to prevent replay attacks.

    Args:
        timestamp (str): The timestamp sent in the request headers.

    Raises:
        ValueError: If the timestamp is older than the allowed time window or improperly formatted.
    """
    try:
        current_time = int(time.time())
        timestamp_int = int(timestamp)
    except ValueError:
        print(f"Error: Invalid timestamp format: {timestamp}")
        raise ValueError("Invalid timestamp format")

    if current_time - timestamp_int > 180:
        print(f"Error: The timestamp on the request is too old. Current time: {current_time}, Timestamp: {timestamp}")
        raise ValueError("The timestamp on the request is too old")

    print("Timestamp validation successful!")

def validate_headers(payload: str, headers: Headers) -> None:
    """
    Validates the headers of an incoming request.

    Ensures that the required headers (`X-Hume-AI-Webhook-Timestamp` and 
    `X-Hume-AI-Webhook-Signature`) are present and valid. Performs HMAC 
    signature validation and timestamp validation.

    Args:
        payload (str): The raw request payload as a string.
        headers (Headers): The headers from the incoming request.

    Raises:
        ValueError: If any validation fails, such as missing headers, invalid
                    signatures, or an outdated timestamp.
    """
    print("Validating headers...")

    timestamp = headers.get("X-Hume-AI-Webhook-Timestamp")
    signature = headers.get("X-Hume-AI-Webhook-Signature")

    if not signature:
        print("Error: Missing HMAC signature.")
        raise ValueError("Missing HMAC signature")

    if not timestamp:
        print("Error: Missing timestamp.")
        raise ValueError("Missing timestamp")

    validate_hmac_signature(payload, timestamp, signature)
    validate_timestamp(timestamp)

async def fetch_weather(parameters: str) -> str:
    """
    Fetches the weather forecast for a given location and temperature scale.

    Args:
        parameters (str): The parameters of the tool call.

    Returns:
        str: The JSON-formatted string of the weather forecast.
    """
    # Retrieve the Geocoding API key from environment variables
    GEOCODING_API_KEY = os.getenv("GEOCODING_API_KEY")
    if not GEOCODING_API_KEY:
        return "ERROR: Geocoding API key is not set."

    tool_parameters = json.loads(parameters)
    location = tool_parameters.get('location')
    temp_scale = tool_parameters.get('format', 'text')

    # Construct the URL for the Geocoding API request
    location_api_url = f"https://geocode.maps.co/search?q={location}&api_key={GEOCODING_API_KEY}"

    # Create an HTTP client that automatically follows redirects
    async with httpx.AsyncClient(follow_redirects=True) as client:
        try:
            # Step 1: Fetch location data
            location_response = await client.get(location_api_url)
            location_response.raise_for_status()
            location_data = location_response.json()
        except httpx.HTTPError as e:
            return f"ERROR: Failed to fetch location data. {str(e)}"

        if not location_data:
            return "ERROR: No location data found."

        try:
            # Extract latitude and longitude from the location data
            lat = location_data[0]['lat']
            lon = location_data[0]['lon']
        except (IndexError, KeyError):
            return "ERROR: Unable to extract latitude and longitude."

        # Construct the URL for the Weather.gov API points endpoint
        point_metadata_endpoint = f"https://api.weather.gov/points/{float(lat):.4f},{float(lon):.4f}"

        try:
            # Step 2: Fetch point metadata
            point_metadata_response = await client.get(point_metadata_endpoint)
            point_metadata_response.raise_for_status()
            point_metadata = point_metadata_response.json()
        except httpx.HTTPError as e:
            return f"ERROR: Failed to fetch point metadata. {str(e)}"

        try:
            # Extract the forecast URL from the point metadata
            forecast_url = point_metadata['properties']['forecast']
        except KeyError:
            return "ERROR: Unable to extract forecast URL from point metadata."

        try:
            # Step 3: Fetch the weather forecast
            forecast_response = await client.get(forecast_url)
            forecast_response.raise_for_status()
            forecast_data = forecast_response.json()
        except httpx.HTTPError as e:
            return f"ERROR: Failed to fetch weather forecast. {str(e)}"

        try:
            # Extract the forecast periods from the response
            periods = forecast_data['properties']['periods']
        except KeyError:
            return "ERROR: Unable to extract forecast periods."

        # Validate the desired temperature format
        desired_unit = temp_scale.lower()
        if desired_unit not in ['fahrenheit', 'celsius']:
            return "ERROR: Invalid format specified. Please use 'fahrenheit' or 'celsius'."

        # Convert temperatures for all periods to the desired unit
        for period in periods:
            temperature = period.get('temperature')
            temperature_unit = period.get('temperatureUnit')

            if temperature is not None and temperature_unit is not None:
                if desired_unit == 'celsius' and temperature_unit == 'F':
                    # Convert Fahrenheit to Celsius
                    converted_temp = round((temperature - 32) * 5 / 9)
                    period['temperature'] = converted_temp
                    period['temperatureUnit'] = 'C'
                elif desired_unit == 'fahrenheit' and temperature_unit == 'C':
                    # Convert Celsius to Fahrenheit
                    converted_temp = round((temperature * 9 / 5) + 32)
                    period['temperature'] = converted_temp
                    period['temperatureUnit'] = 'F'

        # Return the forecast data as a JSON-formatted string
        forecast = json.dumps(periods, indent=2)
        return forecast

async def fetch_weather_tool(
    control_plane_client: AsyncControlPlaneClient, 
    chat_id: str, 
    tool_call_message: ToolCallMessage
) -> None:
    """
    Function which invokes the get_current_weather tool and sends the result back to the chat via the control plane.

    Args:
        control_plane_client (AsyncControlPlaneClient): The control plane client instance.
        chat_id (str): The ID of the chat.
        tool_call_message (ToolCallMessage): The tool call message.
    """
    parameters = tool_call_message.parameters
    tool_call_id = tool_call_message.tool_call_id
    tool_name = tool_call_message.name

    if tool_name != "get_current_weather":
        return
    
    try:
        current_weather = await fetch_weather(parameters)
        await control_plane_client.send(
            chat_id=chat_id, 
            request=ToolResponseMessage(
                tool_call_id=tool_call_id,
                content=current_weather
            )
        )
    except Exception as e:
        print(f"Error fetching weather: {e}")
        await control_plane_client.send(
            chat_id=chat_id, 
            request=ToolErrorMessage(
                tool_call_id=tool_call_id,
                error="WeatherFetchError",
                content=str(e)
            )
        )